# Generated by Django 4.2.16 on 2024-12-21 00:35

from django.db import migrations
from django.db.migrations.operations.base import Operation


class FixRenamedM2MFieldIndexes(Operation):
    """This is a workaround for a Django bug that prevents renaming M2M fields and creating a new field with the old name.

    This operation renames the index for the M2M field to create the index name using the hash of the new table name
    so that it doesn't collide with the old table name. This allows the old table name to be reused.
    Django bug: https://code.djangoproject.com/ticket/23577 (opened in 2014 and still open as of 2025-01-06)
    """

    def __init__(self, model_name, field_name):
        self.model_name = model_name
        self.field_name = field_name

    def state_forwards(self, app_label, state):
        """
        This is a no-op because Django isn't tracking the state of the auto-created M2M table indexes. TODO Django 6 maybe?
        """

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        # Database-specific SQL queries are required in Django 3.2, thus required for Nautobot v2.2. These are built-in to Django 4.0's schema editor.
        sql_rename_index = {
            "postgresql": "ALTER INDEX %s RENAME TO %s",
            "mysql": "ALTER TABLE %s RENAME INDEX %s TO %s",
        }

        model = from_state.apps.get_model(app_label, self.model_name)
        field = model._meta.get_field(self.field_name)
        through_model = field.remote_field.through
        through_model_db_table = through_model._meta.db_table
        through_model_db_table_constraints = schema_editor.connection.introspection.get_constraints(
            schema_editor.connection.cursor(), through_model_db_table
        )
        for constraint_name, constraint in through_model_db_table_constraints.items():
            # Skip primary key constraints
            if constraint.get("primary_key", False):
                continue

            # Change index names
            if constraint.get("index", False):
                new_index_name = schema_editor._create_index_name(through_model_db_table, constraint["columns"])
                if schema_editor.connection.vendor == "mysql":
                    sql = sql_rename_index["mysql"] % (
                        schema_editor.quote_name(through_model_db_table),
                        schema_editor.quote_name(constraint_name),
                        schema_editor.quote_name(new_index_name),
                    )
                    schema_editor.execute(sql)

                elif schema_editor.connection.vendor == "postgresql":
                    sql = sql_rename_index["postgresql"] % (
                        schema_editor.quote_name(constraint_name),
                        schema_editor.quote_name(new_index_name),
                    )
                    schema_editor.execute(sql)

                else:
                    raise NotImplementedError(
                        f"Database {schema_editor.connection.vendor} is not supported for this migration."
                    )

            # Change foreign key constraint names
            if constraint.get("foreign_key", None):
                constraint_suffix = "_fk_%(to_table)s_%(to_column)s"
                field = through_model._meta.get_field(constraint["columns"][0])
                schema_editor.execute(schema_editor._delete_fk_sql(through_model, constraint_name))
                schema_editor.execute(schema_editor._create_fk_sql(through_model, field, constraint_suffix))

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        """
        Since this runs separately from the M2M field rename operation, we can't actually reverse this operation.
        """

    def describe(self):
        """
        Output a brief summary of what the action does.
        """
        return "Fix index names for %s field %s" % (self.model_name, self.field_name)

    @property
    def migration_name_fragment(self):
        return "rename_m2m_index_%s_%s" % (self.model_name.lower(), self.field_name.lower())


class Migration(migrations.Migration):
    dependencies = [
        ("nautobot_device_lifecycle_mgmt", "0024_add_migrated_to_core_software_model_booleans"),
    ]

    operations = [
        migrations.RenameField(
            model_name="cvelcm",
            old_name="affected_softwares",
            new_name="old_affected_softwares",
        ),
        migrations.RenameField(
            model_name="devicesoftwarevalidationresult",
            old_name="software",
            new_name="old_software",
        ),
        migrations.RenameField(
            model_name="inventoryitemsoftwarevalidationresult",
            old_name="software",
            new_name="old_software",
        ),
        migrations.RenameField(
            model_name="validatedsoftwarelcm",
            old_name="software",
            new_name="old_software",
        ),
        migrations.RenameField(
            model_name="vulnerabilitylcm",
            old_name="software",
            new_name="old_software",
        ),
        FixRenamedM2MFieldIndexes(
            model_name="cvelcm",
            field_name="old_affected_softwares",
        ),
    ]
